from .base import ArgSet, Hyperparameter, Observable, ObsSet, Parameter


def as_args(obs: ObsSet) -> ArgSet:
    params = set[Parameter | Hyperparameter]()
    for c in obs:
        p = Parameter(c.typing)
        params.add(p(c.value) if c.initialized else p("some/autogenerated/value"))
    return params


def as_obs(args: ArgSet) -> ObsSet:
    return {Observable(c.typing)(c.value) for c in args}


def union_a(a: ArgSet, o: ObsSet) -> ArgSet:
    """
    Combine arguments with observables, return as arguments

    @param a: a set of arguments
    @param o: a set of observables
    @return: the next argument set

    """
    return a.union(as_args(o))


def union_o(a: ArgSet, o: ObsSet) -> ObsSet:
    """
    Combine arguments with observables, return as observables

    @param a: a set of arguments
    @param o: a set of observables
    @return: the next argument set

    """
    return as_obs(a).union(o)


def int_a(a: ArgSet, o: ObsSet) -> ArgSet:
    """
    Create the next argument set by intersecting the current argument set with the observable set

    @param a: a set of arguments
    @param o: a set of observables
    @return: the intersection as an ArgSet

    """
    return a.intersection(as_args(o))


def int_o(a: ArgSet, o: ObsSet) -> ObsSet:
    """
    Create the next observable set by intersecting the current observable set with the argument set

    @param a: the current argument set
    @param o: the observable set
    @return: the next observable set
    """
    return as_obs(a).intersection(o)


def split(uA: ArgSet, uO: ObsSet) -> tuple[ArgSet, ArgSet, ObsSet]:

    iA = int_a(uA, uO)
    iO = int_o(uA, uO)

    return (
        uA.difference(iA),
        iA,
        uO.difference(iO),
    )
